# Verbs 3: mutate

<style>
   table {
      font-size:.9em;
   }
</style>


## Key takeaways

NOTE: Most journalism tutorials do group_by/summarise BEFORE they introduce mutate. But most computer science tutorials reverse that order. The reason is that journalists often don't have datasets that have many numbers, so the simple arithmetic isn't as important.   

* *mutate* just means "compute", or convert one or more variables into something new. 
* mutate is the same thing as creating a new column in Excel with a formula
* There are several common mutate tasks. The most important for us are:
  * Convert unstandardized data into standardized, such as yes-or-no variables or all lower case
  * Use arithmetic on numeric variables
  * Use conditional statements to put different values on variables, instead of filtering one at a time.
* OPTIONAL:
  * Mutate can replace text or values
  * Change the data *type* from, say, text to date and time.

## Read in some data

Start with the [Arizona immunization data](https://github.com/cronkitedata/rstudyguide/blob/master/data/az-immunizations-grade6.Rda?raw=true) that some other chapters have worked with, loading it and the tidyverse to follow along. 


Here are the packages and data used for this chapter:

```{r message=FALSE}

library(tidyverse)
library(knitr)       # used for slightly better looking tables
library(DT)          # even more options with tables
library(lubridate)   # used for working with dates
library(janitor)     # used to clean up dirty data and change column names.

load("data/az-immunizations-grade6.Rda")  # you may need to change the path to wherever you saved the data

```

## Simple arithmetic

Use the usual arithmetic operators to calculate numbers and create a new column: 

      + Addition
      - Subtraction
      * Multiplication
      / Division
      

This example creates a new data frame called `immune_pct` from a few columns of the original:

```{r}

immune_pct <- 
  grade6_counts %>%
  select ( school_name, city, school_type, enrolled, num_immune_mmr) %>%
  mutate (pct_immune = ( num_immune_mmr/enrolled) * 100) 

```

Here's what it looks like: 

```{r echo=FALSE}

immune_pct %>%
  head() %>%
  kable(digits=1 )

```


## Creating categories 

Sometimes, you want to create categories out of more detailed information. In this case, a threshold of 90 percent immunization is considered the limit under which there is a threat of a measles outbreak, also known as "herd immunity". To categorize each schools as above or under that level, we need to create a new variable that is based on the value of the percentage we just calcluated. That's done using an `if_else` statement, which is in the form: 


      if_else (  condition, 
                 new value if it's true, 
                 new value if it's not true)


For example: 


```{r}

immune_pct <- 
    immune_pct %>%
    mutate (  threshold_met =  if_else   ( pct_immune >= 90, 
                                        "Meets threshold", 
                                         "Below threshold")
            )

```


Now we can do some grouping by the new categories: 

```{r  output="hide"}

immune_pct %>%
    group_by (school_type, threshold_met) %>%
    summarise ( school_ct = n(), 
                enrolled = sum(enrolled)) %>%
    kable()

```


You can practice rolling up by looking at the percent by type.  

```{r}

immune_pct %>%
    group_by (school_type, threshold_met) %>%
    summarise ( schools = n(), 
                students = sum(enrolled)) %>%
    mutate (   pct_school_type = schools / sum(schools, na.rm=TRUE) * 100,
               pct_enrolled = students / sum(students, na.rm=TRUE) * 100 
             ) %>%
    filter ( threshold_met == "Below threshold") %>%
    kable(digits=1)



```



You can read this table to say, "Nearly one-fifth of charter school 6th-graders attended schools that did not meet the immunization standards to prevent measles outbreaks."  (The wording is tough here to avoid saying "schools" over and over! )

This strategy can also be used to set unreal values to the special `NA` as in the MAP murder data that uses the value 999 instead of "unknown" for an age. This is common in survey data. 


## Bonus: Fun with date and time

Sometimes your data came to you as text, but you need to treat it as numbers; sometimes you want to turn something that looks like a date into an actual date, allowing for date math and date functions. This is called changing the `data type`. (This example uses the library `lubridate`, which may not be installed in your computer. If you're following along, you may need to install it in the console.)


```{r message=FALSE}

my_link <- "https://cronkitedata.github.io/cronkite-docs/assets/data/csv/opioidemscalls.csv"
#use it in a read_csv command
opioid_calls_orig <- read_csv(my_link)
opioid_calls <- opioid_calls_orig %>% 
                clean_names() %>%
                select (objectid, incident_date_char = incident_date, narcan= narcan_naloxone_given, is_asu_student, is_homeless=is_homeles)
  

head(opioid_calls)
```


The date and time in this dataset is a character field, but we want to convert it to a date field and a separate time field. Here is an example of doing that, using the library `lubridate`


At first, we might just want to get the date value out of the character string. It's in the form month/day/year hour:minute, so we can use the lubridate::mdy_hm function, which tries to guess how the character string is formatted: 


```{r}

opioid_calls %>%
  mutate ( incident_date = mdy_hm(incident_date_char)) %>%
  select (incident_date, incident_date_char:is_homeless) %>%
  head()


```

Notice that the new variable is of the type <S3: POSIXct>, which refers to a date-time combined variable. 

Let's say I want to distinguish weekends from weekdays in this dataset. First, we have to define weekend. Here's one definition, but you might want to use another: A weekend is anytime after 3pm on Friday through 6pm on Sunday. (The `hour` variable is in military time.)

```{r}

opioid_calls %>%
  mutate (incident_date = mdy_hm(incident_date_char), 
          day_of_week = wday(incident_date) ,
          weekday = weekdays(incident_date),
          hour = hour(incident_date), 
          weekend = 
              case_when ( day_of_week == 7                 ~ "Yes", 
                          day_of_week == 6 & hour >= 15     ~ "Yes", 
                          day_of_week == 1 & hour <= 18   ~ "Yes", 
                          TRUE                             ~ "No"
                          )
          ) %>%
  select (weekend, weekday, hour) %>%
  head (60) %>%
  datatable( )


```



